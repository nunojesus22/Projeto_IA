    ;;; Tabuleiros



(defun tabuleiro-teste ()
 (definir-heuristica 'base)
"Tabuleiro de teste sem nenhuma jogada realizada"
  '(
    (94 25 54 89 21 8 36 14 41 96) 
    (78 47 56 23 5 49 13 12 26 60) 
    (0 27 17 83 34 93 74 52 45 80) 
    (69 9 77 95 55 39 91 73 57 30) 
    (24 15 22 86 1 11 68 79 76 72) 
    (81 48 32 2 64 16 50 37 29 71) 
    (99 51 6 18 53 28 7 63 10 88) 
    (59 42 46 85 90 75 87 43 20 31) 
    (3 61 58 44 65 82 19 4 35 62) 
    (33 70 84 40 66 38 92 67 98 97)
    )
)

(defun tabuleiro-jogado ()
"Tabuleiro de teste igual ao anterior mas tendo sido colocado o cavalo na posiï¿½ï¿½o: i=0 e j=0"
  '(
    (T 25 54 89 21 8 36 14 41 96) 
    (78 47 56 23 5 49 13 12 26 60) 
    (0 27 17 83 34 93 74 52 45 80) 
    (69 9 77 95 55 39 91 73 57 30) 
    (24 15 22 86 1 11 68 79 76 72) 
    (81 48 32 2 64 16 50 37 29 71) 
    (99 51 6 18 53 28 7 63 10 88) 
    (59 42 46 85 90 75 87 43 20 31) 
    (3 61 58 44 65 82 19 4 35 62) 
    (33 70 84 40 66 38 92 67 98 97)
    )
)


;;; Exercicios

#|Funï¿½ï¿½o que recebe um ï¿½ndice e o tabuleiro e retorna uma lista que representa essa linha do tabuleiro.|#
(defun linha (indice tabuleiro)
  "Retorna a linha do tabuleiro correspondente ao ï¿½ndice dado"
  (nth indice tabuleiro))

; (linha 0 (tabuleiro-teste)) -> (94 25 54 89 21 8 36 14 41 96)

#|-----------------------------------------------------------------------------------------------------------|#

#|Funï¿½ï¿½o que recebe dois ï¿½ndices e o tabuleiro e retorna o valor presente nessa cï¿½lula do tabuleiro.|#
(defun celula (linha-indice coluna-indice tabuleiro)
  "Retorna o valor presente na cï¿½lula do tabuleiro correspondente aos ï¿½ndices dados"
  (nth coluna-indice (linha linha-indice tabuleiro))) ;; Obtï¿½m o valor da cï¿½lula na coluna indicada da linha indicada

;; (celula 0 1 (tabuleiro-teste)) -> 25

#|-----------------------------------------------------------------------------------------------------------|#

#|Funï¿½ï¿½o que recebe um nï¿½mero positivo n e cria uma lista com todos os nï¿½meros
entre 0 (inclusivï¿½) e o nï¿½mero passado como argumento (exclusivï¿½). Por default o n ï¿½ 100.|#
(defun lista-numeros (&optional (n 100))
  "Cria uma lista com todos os nï¿½meros de 0 (inclusivo) atï¿½ n (exclusivo). Por padrï¿½o, n ï¿½ 100."
  (cond ((<= n 0) nil)  ;; Caso base: Se n ï¿½ 0 ou negativo, retorna uma lista vazia.
        (t (cons (- n 1) (lista-numeros (- n 1))))))  ;; Constrï¿½i a lista do maior para o menor nï¿½mero.

;; Exemplos de uso:
;; (lista-numeros 5) -> (4 3 2 1 0)
;; (lista-numeros)   -> (99 98 97 ... 3 2 1 0)


#|-----------------------------------------------------------------------------------------------------------|#

#|A funï¿½ï¿½o remover-se (<predicado> <lista>) permite reconstruir uma lista sem os elementos que verificam 
o predicado passado como argumento.|#
(defun remover-se(pred lista)
  (cond ((null lista) NIL) ;; Lista vazia, retorna NIL
        ;; O primeiro elemento da lista satisfaz o predicado, chama recursivamente para a cauda
        ((funcall pred (car lista)) (remover-se pred (cdr lista)))
        ;; O primeiro elemento nï¿½o satisfaz o predicado, consolida o elemento e chama recursivamente para a cauda 
        (T (cons (car lista) (remover-se pred (cdr lista))))))

;; (remover-se #'(lambda (x) (= x 0)) '(1 2 0 2 0 4)) -> (1 2 2 4)

#|Funï¿½ï¿½o recursiva que remove o nï¿½mero da lista igual ao encontrado aleatoriamente|#
(defun baralhar-recursivo (lista)
  "Baralha aleatoriamente os nï¿½meros em uma lista."
  (if (endp lista) ;; Verifica se a lista estï¿½ vazia
      nil ;; Retorna NIL
      ;; Passo 2: Escolhe um nï¿½mero aleatï¿½rio da lista
      (let ((numero (nth (random (length lista)) lista)))
        ;; Passo 3: Adiciona o nï¿½mero escolhido e continua recursivamente removendo-o da lista
        (cons numero (baralhar-recursivo (remover-se (lambda (x) (= x numero)) lista))))))

#|Funï¿½ï¿½o que recebe uma lista e irï¿½ mudar aleatoriamente os seus nï¿½meros.|#
(defun baralhar (lista)
  "Funï¿½ï¿½o principal para baralhar uma lista."
  (baralhar-recursivo lista))

;; (baralhar (lista-numeros))
;; (baralhar (lista-numeros 5))

#|-----------------------------------------------------------------------------------------------------------|#

#|Funï¿½ï¿½o que pega numa lista e cria sublistas de n elementos recorrendo ï¿½ funï¿½ï¿½o subseq que tem um comportamento
semelhante ao substring para strings.
Por default a lista serï¿½ o resultado obtido na alï¿½nea 4 (baralhar (lista-numeros)) e o n ï¿½ 10|#
(defun tabuleiro-aleatorio (&optional (lista (baralhar (lista-numeros))) (n 10))
  "Cria um tabuleiro aleatï¿½rio dividindo a lista em sublistas de tamanho n.
  Por padrï¿½o, a lista ï¿½ o resultado da funï¿½ï¿½o (baralhar (lista-numeros)) e n ï¿½ 10."
  (cond
    ((null lista) nil)  ; Condiï¿½ï¿½o de paragem: se a lista estiver vazia, retorna nil
    (t (cons (subseq lista 0 n) (tabuleiro-aleatorio (subseq lista n) n)))
  )
)

;; (tabuleiro-aleatorio)
;; (tabuleiro-aleatorio (baralhar(lista-numeros)) 5)

#|-----------------------------------------------------------------------------------------------------------|#

#|Funï¿½ï¿½o que recebe um ï¿½ndice, uma lista e um valor (por default o valor ï¿½ NIL) esubstitui pelo valor pretendido 
nessa posiï¿½ï¿½o.|#
(defun substituir-posicao (coluna lista &optional (valor nil))
  ;; Verifica se o ï¿½ndice ï¿½ negativo; se sim, retorna a lista original sem modificaï¿½ï¿½o
  (if (< coluna 0)
      lista
      ;; Divide a lista na posiï¿½ï¿½o indicada e insere o valor na posiï¿½ï¿½o desejada
      (let ((antes (subseq lista 0 coluna))
            (depois (subseq lista (1+ coluna))))
        (append antes (list valor) depois))))

;; (substituir-posicao 0 (linha 0 (tabuleiro-teste))) -> (NIL 25 54 89 21 8 36 14 41 96)
;; (substituir-posicao 0 (linha 0 (tabuleiro-teste)) T) -> (T 25 54 89 21 8 36 14 41 96) 

#|-----------------------------------------------------------------------------------------------------------|#

#|Funï¿½ï¿½o que recebe dois ï¿½ndices, o tabuleiro e um valor (por default o valor ï¿½ NIL). A
funï¿½ï¿½o deverï¿½ retornar o tabuleiro com a cï¿½lula substituï¿½da pelo valor pretendido. Utiliza a funï¿½ï¿½o
substituir-posicao definida anteriormente. |#
(defun substituir (linha-indice coluna-indice tabuleiro &optional (valor nil))
  "Substitui o valor na cï¿½lula indicada pelos ï¿½ndices no tabuleiro.
  - linha-indice: ï¿½ndice da linha na qual realizar a substituiï¿½ï¿½o.
  - coluna-indice: ï¿½ndice da coluna na qual realizar a substituiï¿½ï¿½o.
  - tabuleiro: Tabuleiro no qual realizar a substituiï¿½ï¿½o.
  - valor: Valor a ser inserido na cï¿½lula. Por padrï¿½o, ï¿½ NIL."
  (substituir-posicao linha-indice tabuleiro
                      (substituir-posicao coluna-indice (nth linha-indice tabuleiro) valor)))

;; (substituir 0 0 (tabuleiro-teste) T)

#|-----------------------------------------------------------------------------------------------------------|#

(defun procura-cavalo-na-linha (linha)
  "Procura o cavalo em uma linha especï¿½fica. Retorna a posiï¿½ï¿½o de 'T' ou NIL se nï¿½o encontrado."
  (position 'T linha :test #'eql))

(defun posicao-cavalo (tabuleiro &optional (line 0))
 "Retorna a posicï¿½ï¿½o (x y) de onde se localiza o cavalo"
  (cond    
   ((null tabuleiro) Nil)
   ((equal (find T (car tabuleiro)) T) (list line (position T (car tabuleiro))))
   (t (posicao-cavalo (cdr tabuleiro) (+ line 1)) ))
  )

;; (posicao-cavalo (tabuleiro-teste)) -> NIL
;; (posicao-cavalo (tabuleiro-jogado)) -> (0 0)

#|-----------------------------------------------------------------------------------------------------------|#
#|----------------------------------------------FUNï¿½ï¿½ES AUXILIARES-------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#

(defun numero-maximo-lista (lista)
  "Retorna o maior nï¿½mero da lista fornecido. Se a lista contiver elementos que nï¿½o sï¿½o nï¿½meros, eles sï¿½o 
  removidos da lista e nï¿½o entram nas comparaï¿½ï¿½es."
  (reduce #'max (remove-if-not #'numberp lista))
)

;; (numero-maximo-lista '(NIL 25 54 89 21 8 36 14 41 96)) -> 96

(defun junta-duas-listas (lista1 lista2)
  "Esta função junta duas listas numa só. Se a primeira lista tiver 0 elementos, ele retorna a lista2 apenas."
  (cond
      ((null lista1) lista2)
      ((null lista2) lista1) 
      (T (append lista1 lista2))
  )
)

(defun tabuleiro-numa-lista (tabuleiro)
  "Esta função transforma o tabuleiro (uma lista de listas) numa só lista."
  (cond 
      ((null tabuleiro) NIL)
      (T (junta-duas-listas (car tabuleiro)(tabuleiro-numa-lista (cdr tabuleiro))))
  )
)

(defun pontos-no-tabuleiro (tabuleiro)
  "Soma todos os pontos disponï¿½veis dentro do tabuleiro fornecido."
  (reduce #'+(remove-if-not #'numberp(tabuleiro-numa-lista tabuleiro)))
)

(defun posicoes-livres-tabuleiro (tabuleiro)
  "Conta quantas casas livres (diferentes de NIL e de T) existentes no tabuleiro."
  (count-if (lambda (celula) (and (not (eq celula NIL))(not (eq celula 'T))))
            (tabuleiro-numa-lista tabuleiro)
  )
)

(defun filtrar-apenas-numeros (lista)
  (remove-if-not #'numberp lista))

(defun valores-disponiveis-primeira-linha (tabuleiro)
  "Lista dos valores disponiveis numa linha para posicionar o cavalo no tabuleiro."
  (cond
   ((equal tabuleiro nil)
    nil
   )
   (t
    (filtrar-apenas-numeros (linha 0 tabuleiro))
   )
  )
)

(defun jogadas-disponiveis (lista-no-sucessores)
  (cond
   ((null lista-no-sucessores) 0)
   ((equal lista-no-sucessores  Nil ) 0 )
   ((equal (car lista-no-sucessores)  Nil ) 0 )
   (t (length lista-no-sucessores))
  )
)

(defun existe-na-lista (valor lista)
  (if (member valor lista)
      T
      NIL)
)

(defun cria-no-cavalo-primeira-linha (no valor-posicao)
  (if (equal (existe-na-lista valor-posicao (valores-disponiveis-primeira-linha (estado-tabuleiro no))) NIL)
      NIL
    (criar-no
     (inicializar-cavalo (estado-tabuleiro no) (second (posicao-valor valor-posicao (estado-tabuleiro no) 0)))
     (posicao-valor valor-posicao (estado-tabuleiro no) 0)
     valor-posicao
     0
     NIL
     (no-heuristica no)
    )
  )
)

(defun sucessores-tabuleiro-inicial (no lista-valores-disponiveis)
  "Esta função cria nós para todas as possiveis primerias jogadas"
  (cond
   ((null lista-valores-disponiveis) nil)
   (t (cons 
       (cria-no-cavalo-primeira-linha no (first lista-valores-disponiveis))
       (sucessores-tabuleiro-inicial no (cdr lista-valores-disponiveis))
      )
   )
  )
)


#|-----------------------------------------------------------------------------------------------------------|#
#|----------------------------------------------------REGRAS-------------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#

(defun numero-simetrico (numero)
  "Se o número tem dois dígitos diferentes, retorna o número simétrico. 
   Caso contrário, retorna nil."
  (if (and (>= numero 10) (<= numero 99)) ; Verifica se o número tem dois dígitos
    (let ((digito1 (mod numero 10))
          (digito2 (floor numero 10)))
      (if (/= digito1 digito2) ; Verifica se os dígitos são diferentes.
        (+ (* digito1 10) digito2))))) ; Retorna o número simétrico se os dígitos forem diferentes.

;; (numero-simetrico 57) -> 75
;; (numero-simetrico 44) -> nil (números iguais)
;; (numero-simetrico 123) -> nil (não é um número de dois dígitos)

#|-----------------------------------------------------------------------------------------------------------|#

(defun numero-duplo (numero)
  "Verifica se o número fornecido é um número duplo (dois dígitos iguais).
   Retorna T (true) se for um número duplo, caso contrário retorna NIL (false)."
  (and (not (null numero))
       (not (eq numero T))
       (>= numero 10) (<= numero 99) ; Verifica se o número tem dois dígitos
       (= (mod numero 10) (floor numero 10)))) ; Verifica se os dois dígitos sãp iguais.

;; (numero-duplo 44) -> T
;; (numero-duplo 57) -> NIL
;; (numero-duplo 123) -> NIL (não é um número de dois dígitos)

#|-----------------------------------------------------------------------------------------------------------|#

(defun duplos-existentes(lista)
  "Retorna uma lista dos números duplos que existem numa lista."
  (cond 
      ((null lista) '())
      ((numero-duplo (car lista))
          (cons (car lista) (duplos-existentes (cdr lista))))
      (T (duplos-existentes (cdr lista)))
  )
)

;;(duplos-existentes (linha 1 (tabuleiro-teste))) -> NIL
;;(duplos-existentes (linha 4 (tabuleiro-teste))) -> (22 11)

#|-----------------------------------------------------------------------------------------------------------|#

(defun duplos-existentes-ordenados (tabuleiro)
  "Retorna uma lista de todos os nï¿½meros duplos existentes no tabuleiro ordenados"
  (sort (duplos-existentes (tabuleiro-numa-lista tabuleiro)) #'>)
)

;; (duplos-existentes-ordenados (tabuleiro-teste)) -> (99 88 77 66 55 44 33 22 11)

#|-----------------------------------------------------------------------------------------------------------|#

(defun maximo-duplo (tabuleiro)
  "Retorna o maior nï¿½mero duplo que existe no tabuleiro"
  (numero-maximo-lista (duplos-existentes-ordenados tabuleiro))
)

#|-----------------------------------------------------------------------------------------------------------|#

(defun movimento-valido (linha coluna tabuleiro)
  "Verifica se a posiï¿½ï¿½o para onde se pretende movimentar ï¿½ vï¿½lida. Retorna T em caso de ser vï¿½lido,
   Caso contrï¿½rio retornarï¿½ NIL."
  (and (>= linha 0)(<= linha 9)
       (>= coluna 0)(<= coluna 9) ;; Verifica se a coluna e linha estï¿½o entre 0 e 9
       (not (null (celula linha coluna tabuleiro))) ;; Verifica se a celula para onde se movimenta nï¿½o estï¿½ a NIL
  )
)

;; (movimento-valido 0 1 (tabuleiro-jogado)) -> T
;; (movimento-valido 0 -1 (tabuleiro-jogado)) -> NIL
;; (movimento-valido 0 1 (tabuleiro-jogado)) -> NIL - ISTO PORQUE ALTERAMOS O VALOR DE 25 PARA NIL PARA TESTARMOS
#|-----------------------------------------------------------------------------------------------------------|#

(defun posicao-valor (valor tabuleiro &optional (line 0))
  "Verifica se a posiï¿½ï¿½o para onde se pretende movimentar ï¿½ vï¿½lida. Retorna T em caso de ser vï¿½lido,
   Caso contrï¿½rio retornarï¿½ NIL."
  (if (or (null tabuleiro) (> line 9))
      NIL
      (let* 
          (
             (linha-tabuleiro (linha line tabuleiro))
             (coluna-valor (position valor linha-tabuleiro))
          )
          (if coluna-valor
            (list line coluna-valor)
            (posicao-valor valor tabuleiro (1+ line))
          )
      )
  )
)

;; (posicao-valor 94 (tabuleiro-jogado)) -> NIL
;; (posicao-valor 94 (tabuleiro-teste)) -> (0 0)
;; (posicao-valor 92 (tabuleiro-teste)) -> (9 6)

#|-----------------------------------------------------------------------------------------------------------|#
#|--------------------------------------------------OPERADORES-----------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#


;; (inicializar-cavalo (tabuleiro-teste) 10)


(defun limpar-cavalos (tabuleiro)
  "Remove todos os cavalos ('T') do tabuleiro, substituindo-os por nil."
  (mapcar (lambda (linha) 
            (mapcar (lambda (celula) 
                      (if (eql celula 'T) nil celula))
                    linha))
          tabuleiro))

;; (limpar-cavalos (tabuleiro-teste))


(defun lista-operadores ()
  "Cria uma lista com todos os números dos operadores."
  (list 1 2 3 4 5 6 7 8))



(defun escolhe-operador (tabuleiro numero-operador)
  (if (or (< numero-operador 1) (> numero-operador 8))
      (format t "Nï¿½mero do operador invï¿½lido. Deve ser entre 1 e 8.~%")
 (let ((novo-tabuleiro (copy-list tabuleiro))) ; Cria uma cópia do tabuleiro
      (cond
        ((= numero-operador 1) (operador-geral novo-tabuleiro 2 -1))
        ((= numero-operador 2) (operador-geral novo-tabuleiro 2 1))
        ((= numero-operador 3) (operador-geral novo-tabuleiro 1 2))
        ((= numero-operador 4) (operador-geral novo-tabuleiro -1 2))
        ((= numero-operador 5) (operador-geral novo-tabuleiro -2 1))
        ((= numero-operador 6) (operador-geral novo-tabuleiro -2 -1))
        ((= numero-operador 7) (operador-geral novo-tabuleiro -1 -2))
        ((= numero-operador 8) (operador-geral novo-tabuleiro 1 -1))
        (t (format t "Operador não implementado.~%")))
   )
 )
)


(defun operador-geral (tabuleiro numero-linhas numero-colunas)
  (if (eq (posicao-cavalo tabuleiro) NIL)
      (format t "Cavalo por posicionar.~%")
    (let* ((posicao-cavalo-inicio (posicao-cavalo tabuleiro))
           (nova-linha (+ (first posicao-cavalo-inicio) numero-linhas))
           (nova-coluna (+ (second posicao-cavalo-inicio) numero-colunas))
           (posicao-cavalo-final (list nova-linha nova-coluna))
           (movimento-e-valido (movimento-valido nova-linha nova-coluna tabuleiro)))
      (if (eq movimento-e-valido NIL)
          (progn
            #|(format t "Movimento inválido.~%")|#
            NIL) ; Retorna NIL se o movimento não for válido
        (let* ((simetrico (numero-simetrico (celula nova-linha nova-coluna tabuleiro)))
               (posicao-simetrico (posicao-valor simetrico tabuleiro))
               (e-duplo (numero-duplo (celula nova-linha nova-coluna tabuleiro)))
               (maximo-duplo (maximo-duplo tabuleiro))
               (posicao-duplo (posicao-valor maximo-duplo tabuleiro))
               (novo-tabuleiro tabuleiro)) ; Mantém uma referência ao tabuleiro atual
          (cond 
           ((eq e-duplo T)
            (setf novo-tabuleiro (substituir (first posicao-cavalo-final) (second posicao-cavalo-final)
                           (substituir (first posicao-cavalo-inicio) (second posicao-cavalo-inicio)
                                       (substituir (first posicao-duplo) (second posicao-duplo) tabuleiro NIL)
                                       NIL) 'T)))
           (T
            (setf novo-tabuleiro (substituir (first posicao-cavalo-final) (second posicao-cavalo-final)
                           (substituir (first posicao-cavalo-inicio) (second posicao-cavalo-inicio)
                                       (substituir (first posicao-simetrico) (second posicao-simetrico) tabuleiro NIL)
                                       NIL) 'T))))
          (list novo-tabuleiro posicao-cavalo-final)))))) ; Retorna o novo tabuleiro e a nova posição do cavalo



#|-----------------------------------------------------------------------------------------------------------|#
#|---------------------------------------------------- NÓS --------------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#

(defun criar-no(tabuleiro posicao-do-cavalo pontuacao-atual profundidade no-pai &optional(heuristica 0))
  "Função responsável para criar um nó
   Estrutura do nó: Estado do tabuleiro - Posicao atual do cavalo - Pontuação obtida - Profundidade (equivale
   às jogadas feitas) - Estado anterior do tabuleiro - Heuristica utilizada."
  (list tabuleiro posicao-do-cavalo pontuacao-atual profundidade no-pai heuristica)
)

(defun estado-tabuleiro(no)
  "Função responsável por mostrar o estado do tabuleiro no nó fornecido."
  (first no)
)

(defun posicao-do-cavalo-atual(no)
  "Função responsável por mostrar a posicao atual onde está o cavalo."
  (second no)
)

(defun pontuacao-atual(no)
  "Função responsável por mostrar quantos pontos já se tem no nó."
  (third no)
)

(defun profundidade(no)
  "Função responsável por mostrar a profundidade do nó que representa as jogadas feitas até chegar aquele
   estado"
  (fourth no)
)

(defun no-pai(no)
  "Função responsável por mostrar o nó pai deste, ou seja, o estado do tabuleiro anterior a ter se jogado 
   para chegar aquele estado"
  (fifth no)
)

(defun no-heuristica(no)
  "Função responsável por mostrar a heuristica"
  (sixth no)
)


(defun atingiu-objetivo? (no)
  "Verifica se o nó atual atingiu o objetivo do problema."
  (let ((objetivo (obter-objetivo)))
    (and objetivo (numberp objetivo) (>= (pontuacao-atual no) objetivo))))



(defun somar-pontos (pontos-atuais pontos-casa)
  "Soma os pontos da casa atual aos pontos atuais e retorna o total."
  (+ pontos-atuais pontos-casa))




#|-----------------------------------------------------------------------------------------------------------|#
#|------------------------------------------------- HEURISTICA ----------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#
(let ((heuristica-escolhida nil))
     (defun definir-heuristica(heuristica-pretendida)
       (setf heuristica-escolhida heuristica-pretendida)
     )
     (defun obter-heuristica() 
         (case heuristica-escolhida
             ('base 'h-base)
             ('implementada NIL)
             (otherwise NIL)
         )
     )

     #| HEURISTICA DADA PELO PROFESSOR - BASE 
       h(x) = o(x)/m(x) -> Privelegia casas com maior nómero de pontos.
       m(x) = Média de pontos no tabuleiro.
       o(x) = Número de pontos que falta para atingir objetivo.
      |#
     (defun m-base (no)
       "Esta Função calcula o m(x) da heuristica base consoante o estado do tabuleiro. Se as casas disponiveis ou os pontos no tabuleiro forem 0, então o m será 0 também."
       (if (or(eq (pontos-no-tabuleiro (estado-tabuleiro no)) 0) (eq (posicoes-livres-tabuleiro (estado-tabuleiro no)) 0))
           0
         (float (/ (pontos-no-tabuleiro (estado-tabuleiro no)) (posicoes-livres-tabuleiro (estado-tabuleiro no))))
         )
     )

     (defun o-base (no)
       "Esta Função calcula o o(x) da heuristica base consoante o estado do tabuleiro. Ou seja, para sabermos os pontos conseguidos, percisamos do nó. Tendo o nó, podemos recorrer diretamente a uma das propriedades do nó, a pontuação."
       (if (eq (obter-objetivo) nil)
           NIL
         (float (/ (pontos-no-tabuleiro (estado-tabuleiro no)) (posicoes-livres-tabuleiro (estado-tabuleiro no))))
         )
     )
     
     (defun h-base (no)
       "Esta Função calcula a heuristica do nó, usando o estado do tabuleiro do nó."
       (if (or(eq (o-base no) 0) (eq (m-base no) 0))
           0
           (float (/ (o-base no) (m-base no)))
       )
     )
)




#|-----------------------------------------------------------------------------------------------------------|#
#|-------------------------------------------------- PROBLEMA -----------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#
#| Isto permite que a variavel do problema esteja escondida e não seja manipulável por qualquer um. As funçõess ficam definidas dentro da closure do problema para essas funçõess conseguirem manipular o problema.|#

(let ((problema nil))
     (defun definir-objetivo(problema-pretendido)
       (setf problema problema-pretendido)
     )
     (defun obter-objetivo() 
         (case problema
             ('A 70)
             ('B 60)
             ('C 270)
             ('D 600)
             ('E 300)
             ('F 2000)
             (otherwise NIL)
         )
     )
     (defun obter-problema ()           
         (cond
             ((eq problema NIL) NIL)
             (T problema)
         )
     )
)

#|-----------------------------------------------------------------------------------------------------------|#

(defun inicializar-cavalo (tabuleiro &optional (coluna 0))
  "Coloca o cavalo na coluna selecionada para a primeira jogada e retorna o valor original da célula."
  (let ((novo-tabuleiro (copy-list tabuleiro))
        (valor-celula-original (celula 0 coluna tabuleiro))) ; Sempre obtém o valor original da célula
    (cond
      ((or (> coluna 9) (< coluna 0))
        (progn
          (format t "Coluna inválida.~%")
          (values novo-tabuleiro valor-celula-original))) ; Retorna o tabuleiro sem mudanças e valor da célula
      ((not (eq (posicao-cavalo novo-tabuleiro) NIL))
        (progn
          (format t "Cavalo já colocado.~%")
          (values novo-tabuleiro valor-celula-original))) ; Retorna o tabuleiro sem mudanças e valor da célula
      (T
        (let* ((nova-linha 0)
               (nova-coluna coluna)
               (valor-celula (celula nova-linha nova-coluna novo-tabuleiro))
               (simetrico (numero-simetrico valor-celula))
               (posicao-simetrico (posicao-valor simetrico novo-tabuleiro))
               (e-duplo (numero-duplo valor-celula))
               (maximo-duplo (maximo-duplo novo-tabuleiro))
               (posicao-duplo (posicao-valor maximo-duplo novo-tabuleiro)))
          (setq valor-celula-original valor-celula)
(format t "Cavalo sendo colocado na casa com ~A pontos.~%" valor-celula-original) ; Imprime o número de pontos
          (cond
            ((eq e-duplo T)
              (setf (nth nova-coluna (nth nova-linha novo-tabuleiro)) 'T)
              (setf (nth (second posicao-duplo) (nth (first posicao-duplo) novo-tabuleiro)) NIL))
            (T
              (setf (nth nova-coluna (nth nova-linha novo-tabuleiro)) 'T)
              (setf (nth (second posicao-simetrico) (nth (first posicao-simetrico) novo-tabuleiro)) NIL)))
          (values novo-tabuleiro valor-celula-original))))) ; Retorna o novo tabuleiro modificado, o valor original
)


(defun expandir-no (no)
  "Expande um nó gerando todos os possíveis sucessores baseados nos movimentos do cavalo."
  (let ((tabuleiro-atual (estado-tabuleiro no))
        (pontuacao-atual (pontuacao-atual no))
        (profundidade-atual (profundidade no))
        sucessores)
    (dolist (operador-numero (lista-operadores))
      (let* ((resultado-operador (escolhe-operador tabuleiro-atual operador-numero))
             (novo-tabuleiro (first resultado-operador))
             (nova-posicao (second resultado-operador)))
        (when novo-tabuleiro
          (format t "Movendo para linha ~A, coluna ~A. ~%" (first nova-posicao) (second nova-posicao))
          (let ((valor-celula (celula (first nova-posicao) (second nova-posicao) tabuleiro-atual)))
            (when (numberp valor-celula)
              (let ((nova-pontuacao (+ pontuacao-atual valor-celula)))
                (format t "Pontos obtidos: ~A, Pontuação total: ~A ~%" valor-celula nova-pontuacao)
                (push (criar-no novo-tabuleiro nova-posicao nova-pontuacao (1+ profundidade-atual) no) sucessores)))))))
    (if (null sucessores)
        (format t "Não há mais movimentos possíveis a partir desta posição. ~%"))
    sucessores))

#|-----------------------------------------------------------------------------------------------------------|#
#|----------------------------------------------------- BFS -------------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#

#|
- Utiliza uma estrutura de dados tipo fila (abertos).
- Explora os nós em um nível antes de passar para o próximo nível.
- Adiciona sucessores no final da fila (nconc abertos (list sucessor)).
|#

(defun bfs-recursivo (fila fechados nos-gerados nos-expandidos)
  "Função recursiva auxiliar para BFS. Processa nós de forma recursiva."
  (if (null fila) ; Checa se a fila está vazia
      (let ((fator-ramificacao-media (calcular-fator-ramificacao-media nos-gerados nos-expandidos)))
        (format t "Fator de Ramificação Média: ~A ~%" fator-ramificacao-media)
        (list 'Failure nos-gerados nos-expandidos fator-ramificacao-media)) ; Retorna falha com contadores e fator
      (let* ((no-atual (first fila))
             (resto-fila (rest fila))
             (novos-abertos '()))
        (incf nos-expandidos)
        (dolist (sucessor (expandir-no no-atual))
          (unless (find sucessor fechados :test #'equal)
            (incf nos-gerados)
            (push sucessor novos-abertos)))
        (push no-atual fechados)
        (bfs-recursivo (append resto-fila novos-abertos) fechados nos-gerados nos-expandidos))))



#|
- novos-abertos é uma lista local usada para acumular os sucessores que ainda não foram explorados.
- Utilizamos nconc para concatenar novos-abertos ao final de abertos. Como nconc modifica a lista original, 
usamos reverse em novos-abertos para manter a ordem correta dos sucessores.
- A função então chama a si mesma recursivamente com a nova lista de abertos e a lista de fechados atualizada.
|#

(defun bfs (tabuleiro-problema)
  "Executa a busca em largura (BFS) no problema do tabuleiro para atingir o objetivo."
  (let* ((valor-celula-inicial (celula 0 0 tabuleiro-problema))
         (tabuleiro-inicializado (inicializar-cavalo tabuleiro-problema))
         (pontuacao-inicial (+ (if (numberp valor-celula-inicial) valor-celula-inicial 0) 2))
         (abertos (list (criar-no tabuleiro-inicializado (posicao-cavalo tabuleiro-inicializado) pontuacao-inicial 0 nil)))
         (tempo-execucao (* (medir-tempo-execucao 'bfs-recursivo abertos '() 0 0) 1000))) ; Convertendo para milissegundos
    (format t "Tempo de execução: ~A milissegundos~%" tempo-execucao)
    tempo-execucao))



#|-----------------------------------------------------------------------------------------------------------|#
#|----------------------------------------------------- DFS -------------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#

#|
- Utiliza uma estrutura de dados tipo pilha (abertos).
- Explora profundamente cada caminho possível antes de recuar.
- Adiciona sucessores no topo da pilha (push sucessor abertos).
|#

(defun dfs-recursivo (abertos fechados nos-gerados nos-expandidos)
  "Função recursiva auxiliar para DFS. Processa nós de forma recursiva."
  (if abertos
      (let ((no-atual (pop abertos)))
        (incf nos-expandidos)
        (dolist (sucessor (expandir-no no-atual))
          (unless (find sucessor fechados :test #'equal)
            (incf nos-gerados)
            (if (atingiu-objetivo? sucessor)
                (let ((fator-ramificacao-media (calcular-fator-ramificacao-media nos-gerados nos-expandidos)))
                  (format t "Fator de Ramificação Média (DFS): ~A~%" fator-ramificacao-media)
                  (return (list 'Success sucessor nos-gerados nos-expandidos fator-ramificacao-media)))
                (push sucessor abertos))))
        (push no-atual fechados)
        (dfs-recursivo abertos fechados nos-gerados nos-expandidos))
      (let ((fator-ramificacao-media (calcular-fator-ramificacao-media nos-gerados nos-expandidos)))
        (format t "Fator de Ramificação Média (DFS): ~A~%" fator-ramificacao-media)
        (list 'Failure nos-gerados nos-expandidos fator-ramificacao-media))))



(defun dfs (tabuleiro-problema)
  "Executa a busca em profundidade (DFS) no problema do tabuleiro para atingir o objetivo."
  (let* ((valor-celula-inicial (celula 0 0 tabuleiro-problema))
         (tabuleiro-inicializado (inicializar-cavalo tabuleiro-problema))
         (pontuacao-inicial (+ (if (numberp valor-celula-inicial) valor-celula-inicial 0) 2))
         (start-time (get-internal-real-time))
         (resultado (dfs-recursivo (list (criar-no tabuleiro-inicializado (posicao-cavalo tabuleiro-inicializado) pontuacao-inicial 0 nil)) '() 0 0))
         (end-time (get-internal-real-time))
         (tempo-execucao (* (/ (- end-time start-time) internal-time-units-per-second) 1000)))
    (format t "Tempo de execução (DFS): ~A milissegundos~%" tempo-execucao)
    resultado))


#|-----------------------------------------------------------------------------------------------------------|#
#|----------------------------------------------------- A* --------------------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#

(defun f (no)
  "Calcula a função de avaliação f para o nó usando a heurística escolhida."
  (let ((heuristica (obter-heuristica)))
    (if (functionp heuristica)
        (+ (profundidade no) ; g(n): custo do caminho do nó inicial até n
           (funcall heuristica no)) ; h(n): heurística do nó até o objetivo
        (profundidade no)))
) ; Se não houver heurística, usa apenas g(n)

(defun merge-sort (list)
  (if (small list) list
	  (merge-lists
		(merge-sort (left-half list))
		(merge-sort (right-half list)))))

(defun small (list)
  (or (null list) (null (cdr list))))

(defun right-half (list)
  (last list (ceiling (/ (length list) 2))))
(defun left-half (list)
  (ldiff list (right-half list)))

(defun merge-lists (list1 list2)
  "Funde duas listas de nós ordenadas com base na função de avaliação f."
  (merge 'list list1 list2 (lambda (no1 no2) (< (f no1) (f no2)))))


(defun a-estrela-recursivo (abertos fechados nos-gerados nos-expandidos)
  "Função recursiva auxiliar para o algoritmo A*."
  (block a-estrela-bloco
    (if (null abertos)
        (let ((fator-ramificacao-media (calcular-fator-ramificacao-media nos-gerados nos-expandidos)))
          (format t "Fator de Ramificação Média (A*): ~A~%" fator-ramificacao-media)
          (list 'Failure nos-gerados nos-expandidos fator-ramificacao-media))
        (let* ((no-atual (first abertos))
               (abertos-restantes (rest abertos))
               (sucessores (expandir-no no-atual)))
          (incf nos-expandidos)
          (when (atingiu-objetivo? no-atual)
            (let ((fator-ramificacao-media (calcular-fator-ramificacao-media nos-gerados nos-expandidos)))
              (format t "Fator de Ramificação Média (A*): ~A~%" fator-ramificacao-media)
              (return-from a-estrela-bloco (list 'Success no-atual nos-gerados nos-expandidos fator-ramificacao-media))))
          (dolist (sucessor sucessores)
            (unless (find sucessor fechados :test #'equal)
              (push sucessor abertos-restantes)
              (incf nos-gerados)))
          (push no-atual fechados)
          (a-estrela-recursivo (merge-sort abertos-restantes) fechados nos-gerados nos-expandidos))))) 



(defun a-estrela (tabuleiro-problema)
  "Executa o algoritmo A* no problema do tabuleiro para atingir o objetivo."
  (let* ((valor-celula-inicial (celula 0 0 tabuleiro-problema))
         (tabuleiro-inicializado (inicializar-cavalo tabuleiro-problema))
         (pontuacao-inicial (+ (if (numberp valor-celula-inicial) valor-celula-inicial 0) 2))
         (start-time (get-internal-real-time))
         (resultado (a-estrela-recursivo (list (criar-no tabuleiro-inicializado (posicao-cavalo tabuleiro-inicializado) pontuacao-inicial 0 nil)) '() 0 0))
         (end-time (get-internal-real-time))
         (tempo-execucao (* (/ (- end-time start-time) internal-time-units-per-second) 1000)))
    (format t "Tempo de execução (A*): ~A milissegundos~%" tempo-execucao)
    resultado))


#|-----------------------------------------------------------------------------------------------------------|#
#|------------------------------------------- ESTATÍSTICAS DE DADOS -----------------------------------------|#
#|-----------------------------------------------------------------------------------------------------------|#

(defun medir-tempo-execucao (funcao &rest args)
  (let ((start (get-internal-real-time)))
    (apply funcao args)
    (let ((end (get-internal-real-time)))
      (/ (- end start) internal-time-units-per-second))))

(defun calcular-fator-ramificacao-media (nos-gerados nos-expandidos)
  (if (> nos-expandidos 0)
      (/ (float nos-gerados) nos-expandidos)
      0))